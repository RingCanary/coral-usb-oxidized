use std::fmt;
use std::time::Duration;
use rusb::{Context, Device, DeviceDescriptor, UsbContext};
use std::ptr;
use std::ffi::CString;
use std::os::raw::c_char;

// Coral USB Accelerator device information
// Initial device ID when first connected
pub const CORAL_USB_VENDOR_ID: u16 = 0x1a6e;  // Global Unichip Corp.
pub const CORAL_USB_PRODUCT_ID: u16 = 0x089a; // Coral USB Accelerator

// Device ID after initialization/first inference
pub const CORAL_USB_VENDOR_ID_INITIALIZED: u16 = 0x18d1;  // Google Inc.
pub const CORAL_USB_PRODUCT_ID_INITIALIZED: u16 = 0x9302; // Coral USB Accelerator (initialized)

// EdgeTPU device type enum
#[repr(C)]
pub enum EdgeTPUDeviceType {
    EdgetpuApexPci = 0,
    EdgetpuApexUsb = 1,
}

// EdgeTPU option struct
#[repr(C)]
pub struct EdgeTPUOption {
    name: *const c_char,
    value: *const c_char,
}

// Raw EdgeTPU delegate type from C API
#[repr(C)]
pub struct EdgeTPUDelegateRaw {
    _private: [u8; 0], // Opaque struct
}

// Define a custom type for the EdgeTPU delegate
pub type EdgeTPUDelegatePtr = *mut EdgeTPUDelegateRaw;

#[derive(Debug)]
pub enum CoralError {
    DeviceCreationFailed,
    DeviceListFailed,
    InvalidDeviceName,
    DeviceNotFound,
    InitializationFailed,
    PermissionDenied,
    UsbError(rusb::Error),
    DelegateCreationFailed,
    LibraryNotFound,
}

impl fmt::Display for CoralError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CoralError::DeviceCreationFailed => write!(f, "Failed to create EdgeTPU device"),
            CoralError::DeviceListFailed => write!(f, "Failed to list EdgeTPU devices"),
            CoralError::InvalidDeviceName => write!(f, "Invalid device name"),
            CoralError::DeviceNotFound => write!(f, "No Coral USB Accelerator found"),
            CoralError::InitializationFailed => write!(f, "EdgeTPU initialization failed - possible fake device"),
            CoralError::PermissionDenied => write!(f, "Permission denied - check USB access rights"),
            CoralError::UsbError(e) => write!(f, "USB error: {}", e),
            CoralError::DelegateCreationFailed => write!(f, "Failed to create EdgeTPU delegate"),
            CoralError::LibraryNotFound => write!(f, "EdgeTPU library not found or incompatible"),
        }
    }
}

impl std::error::Error for CoralError {}

impl From<rusb::Error> for CoralError {
    fn from(error: rusb::Error) -> Self {
        match error {
            rusb::Error::Access => CoralError::PermissionDenied,
            rusb::Error::NoDevice => CoralError::DeviceNotFound,
            rusb::Error::NotFound => CoralError::DeviceNotFound,
            rusb::Error::Io => CoralError::InitializationFailed,
            rusb::Error::Pipe => CoralError::InitializationFailed,
            rusb::Error::InvalidParam => CoralError::InitializationFailed,
            _ => CoralError::UsbError(error),
        }
    }
}

// FFI bindings for libedgetpu
#[link(name = "edgetpu")]
extern "C" {
    #[link_name = "edgetpu_create_delegate"]
    fn edgetpu_create_delegate(
        device_type: EdgeTPUDeviceType,
        name: *const c_char,
        options: *const EdgeTPUOption,
        num_options: usize,
    ) -> EdgeTPUDelegatePtr;
    
    #[link_name = "edgetpu_free_delegate"]
    fn edgetpu_free_delegate(delegate: EdgeTPUDelegatePtr);
    
    #[link_name = "edgetpu_version"]
    fn edgetpu_version() -> *const c_char;
}

// Function pointers for dynamic loading of libedgetpu
#[derive(Clone)]
struct EdgeTPULibrary {
    create_delegate: Option<unsafe extern "C" fn(
        EdgeTPUDeviceType,
        *const c_char,
        *const EdgeTPUOption,
        usize,
    ) -> EdgeTPUDelegatePtr>,
    free_delegate: Option<unsafe extern "C" fn(EdgeTPUDelegatePtr)>,
    version: Option<unsafe extern "C" fn() -> *const c_char>,
}

impl EdgeTPULibrary {
    fn new() -> Result<Self, CoralError> {
        // This is a simplified implementation that assumes the library is already loaded
        // In a real implementation, you would use libloading crate to dynamically load the library
        Ok(EdgeTPULibrary {
            create_delegate: Some(edgetpu_create_delegate),
            free_delegate: Some(edgetpu_free_delegate),
            version: Some(edgetpu_version),
        })
    }
    
    unsafe fn create_delegate(
        &self,
        device_type: EdgeTPUDeviceType,
        name: *const c_char,
        options: *const EdgeTPUOption,
        num_options: usize,
    ) -> Result<EdgeTPUDelegatePtr, CoralError> {
        match self.create_delegate {
            Some(func) => {
                let delegate = func(device_type, name, options, num_options);
                if delegate.is_null() {
                    Err(CoralError::DelegateCreationFailed)
                } else {
                    Ok(delegate)
                }
            },
            None => Err(CoralError::LibraryNotFound),
        }
    }
    
    unsafe fn free_delegate(&self, delegate: EdgeTPUDelegatePtr) -> Result<(), CoralError> {
        match self.free_delegate {
            Some(func) => {
                func(delegate);
                Ok(())
            },
            None => Err(CoralError::LibraryNotFound),
        }
    }
    
    unsafe fn get_version(&self) -> Result<String, CoralError> {
        match self.version {
            Some(func) => {
                let c_str = func();
                if c_str.is_null() {
                    return Err(CoralError::LibraryNotFound);
                }
                let c_str = std::ffi::CStr::from_ptr(c_str);
                match c_str.to_str() {
                    Ok(s) => Ok(s.to_string()),
                    Err(_) => Err(CoralError::LibraryNotFound),
                }
            },
            None => Err(CoralError::LibraryNotFound),
        }
    }
}

// TensorFlow Lite C API types
pub enum TfLiteModel {}
pub enum TfLiteInterpreter {}
pub enum TfLiteTensor {}
pub enum TfLiteDelegate {}

// TensorFlow Lite C API functions
extern "C" {
    fn TfLiteModelCreate(model_data: *const u8, model_size: usize) -> *mut TfLiteModel;
    fn TfLiteModelDelete(model: *mut TfLiteModel);
    fn TfLiteInterpreterCreate(model: *mut TfLiteModel, options: *mut std::ffi::c_void) -> *mut TfLiteInterpreter;
    fn TfLiteInterpreterSetNumThreads(interpreter: *mut TfLiteInterpreter, num_threads: i32) -> i32;
    fn TfLiteInterpreterAllocateTensors(interpreter: *mut TfLiteInterpreter) -> i32;
    fn TfLiteInterpreterInvoke(interpreter: *mut TfLiteInterpreter) -> i32;
    fn TfLiteInterpreterDelete(interpreter: *mut TfLiteInterpreter);
    fn TfLiteInterpreterGetInputTensorCount(interpreter: *mut TfLiteInterpreter) -> i32;
    fn TfLiteInterpreterGetOutputTensorCount(interpreter: *mut TfLiteInterpreter) -> i32;
    fn TfLiteInterpreterGetInputTensor(interpreter: *mut TfLiteInterpreter, input_index: i32) -> *mut TfLiteTensor;
    fn TfLiteInterpreterGetOutputTensor(interpreter: *mut TfLiteInterpreter, output_index: i32) -> *mut TfLiteTensor;
    fn TfLiteTensorType(tensor: *mut TfLiteTensor) -> i32;
    fn TfLiteTensorNumDims(tensor: *mut TfLiteTensor) -> i32;
    fn TfLiteTensorDim(tensor: *mut TfLiteTensor, dim_index: i32) -> i32;
    fn TfLiteTensorByteSize(tensor: *mut TfLiteTensor) -> usize;
    fn TfLiteTensorData(tensor: *mut TfLiteTensor) -> *mut std::ffi::c_void;
    fn TfLiteTensorName(tensor: *mut TfLiteTensor) -> *const i8;
    fn TfLiteTensorCopyFromBuffer(tensor: *mut TfLiteTensor, input_data: *const std::ffi::c_void, input_data_size: usize) -> i32;
    fn TfLiteTensorCopyToBuffer(tensor: *mut TfLiteTensor, output_data: *mut std::ffi::c_void, output_data_size: usize) -> i32;
    fn TfLiteInterpreterModifyGraphWithDelegate(interpreter: *mut TfLiteInterpreter, delegate: *mut TfLiteDelegate) -> i32;
}

/// Error types specific to TensorFlow Lite operations
#[derive(Debug)]
pub enum TfLiteError {
    /// Failed to load the model
    ModelLoadFailed,
    /// Failed to create the interpreter
    InterpreterCreationFailed,
    /// Failed to allocate tensors
    TensorAllocationFailed,
    /// Failed to run inference
    InferenceFailed,
    /// Failed to copy data to or from tensors
    TensorCopyFailed,
    /// Input/output tensor count mismatch
    TensorCountMismatch,
    /// Invalid tensor dimensions
    InvalidTensorDimensions,
    /// Invalid tensor type
    InvalidTensorType,
    /// Failed to modify graph with delegate
    DelegateModificationFailed,
    /// Other error with message
    Other(String),
}

impl std::fmt::Display for TfLiteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TfLiteError::ModelLoadFailed => write!(f, "Failed to load TensorFlow Lite model"),
            TfLiteError::InterpreterCreationFailed => write!(f, "Failed to create TensorFlow Lite interpreter"),
            TfLiteError::TensorAllocationFailed => write!(f, "Failed to allocate TensorFlow Lite tensors"),
            TfLiteError::InferenceFailed => write!(f, "Failed to run TensorFlow Lite inference"),
            TfLiteError::TensorCopyFailed => write!(f, "Failed to copy data to or from TensorFlow Lite tensors"),
            TfLiteError::TensorCountMismatch => write!(f, "Input/output tensor count mismatch"),
            TfLiteError::InvalidTensorDimensions => write!(f, "Invalid tensor dimensions"),
            TfLiteError::InvalidTensorType => write!(f, "Invalid tensor type"),
            TfLiteError::DelegateModificationFailed => write!(f, "Failed to modify graph with delegate"),
            TfLiteError::Other(msg) => write!(f, "TensorFlow Lite error: {}", msg),
        }
    }
}

impl std::error::Error for TfLiteError {}

/// TensorFlow Lite model wrapper
pub struct TfLiteModelWrapper {
    model: *mut TfLiteModel,
}

impl TfLiteModelWrapper {
    /// Create a new TensorFlow Lite model from a file
    pub fn new_from_file(model_path: &str) -> Result<Self, TfLiteError> {
        let model_data = std::fs::read(model_path).map_err(|_| TfLiteError::ModelLoadFailed)?;
        
        let model = unsafe {
            let model_ptr = TfLiteModelCreate(model_data.as_ptr(), model_data.len());
            if model_ptr.is_null() {
                return Err(TfLiteError::ModelLoadFailed);
            }
            model_ptr
        };
        
        Ok(TfLiteModelWrapper { model })
    }
    
    /// Create a new TensorFlow Lite model from memory
    pub fn new_from_memory(model_data: &[u8]) -> Result<Self, TfLiteError> {
        let model = unsafe {
            let model_ptr = TfLiteModelCreate(model_data.as_ptr(), model_data.len());
            if model_ptr.is_null() {
                return Err(TfLiteError::ModelLoadFailed);
            }
            model_ptr
        };
        
        Ok(TfLiteModelWrapper { model })
    }
    
    /// Get the raw model pointer
    pub fn as_ptr(&self) -> *mut TfLiteModel {
        self.model
    }
}

impl Drop for TfLiteModelWrapper {
    fn drop(&mut self) {
        if !self.model.is_null() {
            unsafe {
                TfLiteModelDelete(self.model);
            }
        }
    }
}

/// TensorFlow Lite interpreter with EdgeTPU delegate
pub struct CoralInterpreter {
    interpreter: *mut TfLiteInterpreter,
    _model: TfLiteModelWrapper, // Keep the model alive as long as the interpreter is alive
    _delegate: EdgeTPUDelegate, // Keep the delegate alive as long as the interpreter is alive
}

impl CoralInterpreter {
    /// Create a new TensorFlow Lite interpreter with an EdgeTPU delegate
    pub fn new(model_path: &str, delegate: &EdgeTPUDelegate) -> Result<Self, TfLiteError> {
        let model = TfLiteModelWrapper::new_from_file(model_path)?;
        
        let interpreter = unsafe {
            let interpreter_ptr = TfLiteInterpreterCreate(model.as_ptr(), std::ptr::null_mut());
            if interpreter_ptr.is_null() {
                return Err(TfLiteError::InterpreterCreationFailed);
            }
            
            // Add the EdgeTPU delegate to the interpreter
            let status = TfLiteInterpreterModifyGraphWithDelegate(
                interpreter_ptr, 
                delegate.as_ptr() as *mut TfLiteDelegate
            );
            
            if status != 0 {
                TfLiteInterpreterDelete(interpreter_ptr);
                return Err(TfLiteError::DelegateModificationFailed);
            }
            
            interpreter_ptr
        };
        
        // Allocate tensors
        let status = unsafe { TfLiteInterpreterAllocateTensors(interpreter) };
        if status != 0 {
            unsafe { TfLiteInterpreterDelete(interpreter) };
            return Err(TfLiteError::TensorAllocationFailed);
        }
        
        // Clone the delegate to keep it alive
        let delegate_clone = delegate.clone();
        
        Ok(CoralInterpreter { 
            interpreter,
            _model: model,
            _delegate: delegate_clone,
        })
    }
    
    /// Set the number of threads to use for inference
    pub fn set_num_threads(&self, num_threads: i32) -> Result<(), TfLiteError> {
        let status = unsafe { TfLiteInterpreterSetNumThreads(self.interpreter, num_threads) };
        if status != 0 {
            return Err(TfLiteError::Other(format!("Failed to set number of threads: {}", status)));
        }
        Ok(())
    }
    
    /// Get the number of input tensors
    pub fn input_tensor_count(&self) -> i32 {
        unsafe { TfLiteInterpreterGetInputTensorCount(self.interpreter) }
    }
    
    /// Get the number of output tensors
    pub fn output_tensor_count(&self) -> i32 {
        unsafe { TfLiteInterpreterGetOutputTensorCount(self.interpreter) }
    }
    
    /// Copy data to an input tensor
    pub fn copy_to_input_tensor(&self, input_index: i32, input_data: &[u8]) -> Result<(), TfLiteError> {
        let tensor = unsafe { TfLiteInterpreterGetInputTensor(self.interpreter, input_index) };
        if tensor.is_null() {
            return Err(TfLiteError::Other(format!("Input tensor at index {} not found", input_index)));
        }
        
        let tensor_size = unsafe { TfLiteTensorByteSize(tensor) };
        if tensor_size != input_data.len() {
            return Err(TfLiteError::TensorCopyFailed);
        }
        
        let status = unsafe {
            TfLiteTensorCopyFromBuffer(
                tensor,
                input_data.as_ptr() as *const std::ffi::c_void,
                input_data.len()
            )
        };
        
        if status != 0 {
            return Err(TfLiteError::TensorCopyFailed);
        }
        
        Ok(())
    }
    
    /// Copy data from an output tensor
    pub fn copy_from_output_tensor(&self, output_index: i32, output_data: &mut [u8]) -> Result<(), TfLiteError> {
        let tensor = unsafe { TfLiteInterpreterGetOutputTensor(self.interpreter, output_index) };
        if tensor.is_null() {
            return Err(TfLiteError::Other(format!("Output tensor at index {} not found", output_index)));
        }
        
        let tensor_size = unsafe { TfLiteTensorByteSize(tensor) };
        if tensor_size != output_data.len() {
            return Err(TfLiteError::TensorCopyFailed);
        }
        
        let status = unsafe {
            TfLiteTensorCopyToBuffer(
                tensor,
                output_data.as_mut_ptr() as *mut std::ffi::c_void,
                output_data.len()
            )
        };
        
        if status != 0 {
            return Err(TfLiteError::TensorCopyFailed);
        }
        
        Ok(())
    }
    
    /// Get input tensor dimensions
    pub fn input_tensor_dims(&self, input_index: i32) -> Result<Vec<i32>, TfLiteError> {
        let tensor = unsafe { TfLiteInterpreterGetInputTensor(self.interpreter, input_index) };
        if tensor.is_null() {
            return Err(TfLiteError::Other(format!("Input tensor at index {} not found", input_index)));
        }
        
        let num_dims = unsafe { TfLiteTensorNumDims(tensor) };
        let mut dims = Vec::with_capacity(num_dims as usize);
        
        for i in 0..num_dims {
            let dim = unsafe { TfLiteTensorDim(tensor, i) };
            dims.push(dim);
        }
        
        Ok(dims)
    }
    
    /// Get output tensor dimensions
    pub fn output_tensor_dims(&self, output_index: i32) -> Result<Vec<i32>, TfLiteError> {
        let tensor = unsafe { TfLiteInterpreterGetOutputTensor(self.interpreter, output_index) };
        if tensor.is_null() {
            return Err(TfLiteError::Other(format!("Output tensor at index {} not found", output_index)));
        }
        
        let num_dims = unsafe { TfLiteTensorNumDims(tensor) };
        let mut dims = Vec::with_capacity(num_dims as usize);
        
        for i in 0..num_dims {
            let dim = unsafe { TfLiteTensorDim(tensor, i) };
            dims.push(dim);
        }
        
        Ok(dims)
    }
    
    /// Get input tensor name
    pub fn input_tensor_name(&self, input_index: i32) -> Result<String, TfLiteError> {
        let tensor = unsafe { TfLiteInterpreterGetInputTensor(self.interpreter, input_index) };
        if tensor.is_null() {
            return Err(TfLiteError::Other(format!("Input tensor at index {} not found", input_index)));
        }
        
        let name_ptr = unsafe { TfLiteTensorName(tensor) };
        if name_ptr.is_null() {
            return Ok(String::new());
        }
        
        let name = unsafe { std::ffi::CStr::from_ptr(name_ptr) };
        Ok(name.to_string_lossy().into_owned())
    }
    
    /// Get output tensor name
    pub fn output_tensor_name(&self, output_index: i32) -> Result<String, TfLiteError> {
        let tensor = unsafe { TfLiteInterpreterGetOutputTensor(self.interpreter, output_index) };
        if tensor.is_null() {
            return Err(TfLiteError::Other(format!("Output tensor at index {} not found", output_index)));
        }
        
        let name_ptr = unsafe { TfLiteTensorName(tensor) };
        if name_ptr.is_null() {
            return Ok(String::new());
        }
        
        let name = unsafe { std::ffi::CStr::from_ptr(name_ptr) };
        Ok(name.to_string_lossy().into_owned())
    }
    
    /// Run inference
    pub fn run(&self) -> Result<(), TfLiteError> {
        let status = unsafe { TfLiteInterpreterInvoke(self.interpreter) };
        if status != 0 {
            return Err(TfLiteError::InferenceFailed);
        }
        Ok(())
    }
}

impl Drop for CoralInterpreter {
    fn drop(&mut self) {
        if !self.interpreter.is_null() {
            unsafe {
                TfLiteInterpreterDelete(self.interpreter);
            }
        }
    }
}

/// EdgeTPU Delegate for TensorFlow Lite
///
/// This struct encapsulates the EdgeTPU delegate used to offload
/// TensorFlow Lite operations to the EdgeTPU hardware.
#[derive(Clone)]
pub struct EdgeTPUDelegate {
    raw: EdgeTPUDelegatePtr,
    library: Option<EdgeTPULibrary>,
}

impl EdgeTPUDelegate {
    /// Create a new EdgeTPU delegate for USB device
    ///
    /// This function creates a new EdgeTPU delegate for the USB device type,
    /// which is the type used by the Coral USB Accelerator.
    pub fn new() -> Result<Self, CoralError> {
        // Check if the device is actually connected
        if !is_device_connected() {
            return Err(CoralError::DeviceNotFound);
        }
        
        // Load the EdgeTPU library
        let library = EdgeTPULibrary::new()?;
        
        unsafe {
            let delegate = library.create_delegate(
                EdgeTPUDeviceType::EdgetpuApexUsb,
                ptr::null(),
                ptr::null(),
                0,
            )?;
            Ok(EdgeTPUDelegate { 
                raw: delegate,
                library: Some(library),
            })
        }
    }
    
    /// Create a new EdgeTPU delegate with custom options
    ///
    /// This function creates a new EdgeTPU delegate with custom options
    /// provided as a string. The options string format depends on the
    /// libedgetpu implementation.
    pub fn with_options(options_str: &str) -> Result<Self, CoralError> {
        // Check if the device is actually connected
        if !is_device_connected() {
            return Err(CoralError::DeviceNotFound);
        }
        
        // Parse options string as key-value pairs
        let mut options = Vec::new();
        let mut option_cstrings = Vec::new();
        
        if !options_str.is_empty() && options_str != "{}" {
            // Very simple JSON parsing for demonstration
            // In a real implementation, you would use a proper JSON parser
            let trimmed = options_str.trim_start_matches('{').trim_end_matches('}').trim();
            if !trimmed.is_empty() {
                for pair in trimmed.split(',') {
                    let parts: Vec<&str> = pair.split(':').collect();
                    if parts.len() == 2 {
                        let key = parts[0].trim().trim_matches('"');
                        let value = parts[1].trim().trim_matches('"');
                        
                        let key_cstr = match CString::new(key) {
                            Ok(s) => s,
                            Err(_) => return Err(CoralError::DelegateCreationFailed),
                        };
                        let value_cstr = match CString::new(value) {
                            Ok(s) => s,
                            Err(_) => return Err(CoralError::DelegateCreationFailed),
                        };
                        
                        option_cstrings.push((key_cstr, value_cstr));
                    }
                }
            }
        }
        
        // Create EdgeTPUOption structs from the parsed options
        for (key, value) in &option_cstrings {
            options.push(EdgeTPUOption {
                name: key.as_ptr(),
                value: value.as_ptr(),
            });
        }
        
        // Load the EdgeTPU library
        let library = EdgeTPULibrary::new()?;
        
        unsafe {
            let delegate = library.create_delegate(
                EdgeTPUDeviceType::EdgetpuApexUsb,
                ptr::null(),
                if options.is_empty() { ptr::null() } else { options.as_ptr() },
                options.len(),
            )?;
            Ok(EdgeTPUDelegate { 
                raw: delegate,
                library: Some(library),
            })
        }
    }
    
    /// Get the raw pointer to the EdgeTPU delegate
    pub fn as_ptr(&self) -> EdgeTPUDelegatePtr {
        self.raw
    }

    /// Check if the delegate is valid
    ///
    /// This function returns true if the delegate is valid and can be used
    /// for inference, false otherwise.
    pub fn is_valid(&self) -> bool {
        !self.raw.is_null()
    }
}

impl Drop for EdgeTPUDelegate {
    fn drop(&mut self) {
        if !self.raw.is_null() {
            unsafe {
                if let Some(library) = &self.library {
                    let _ = library.free_delegate(self.raw);
                } else {
                    edgetpu_free_delegate(self.raw);
                }
                self.raw = ptr::null_mut();
            }
        }
    }
}

pub struct CoralDevice {
    is_valid: bool,
    name: Option<String>,
    vendor_id: u16,
    product_id: u16,
    // We could store a device handle here in a real implementation
}

impl CoralDevice {
    /// Create a new Coral device using the default device
    pub fn new() -> Result<Self, CoralError> {
        // Check if the device is actually connected
        if !is_device_connected() {
            return Err(CoralError::DeviceNotFound);
        }
        
        Ok(CoralDevice { 
            is_valid: true,
            name: None,
            vendor_id: CORAL_USB_VENDOR_ID,
            product_id: CORAL_USB_PRODUCT_ID,
        })
    }
    
    /// Create a new Coral device with a specific device name
    pub fn with_device_name(device_name: &str) -> Result<Self, CoralError> {
        if device_name.is_empty() {
            return Err(CoralError::InvalidDeviceName);
        }
        
        // Check if the device is actually connected
        if !is_device_connected() {
            return Err(CoralError::DeviceNotFound);
        }
        
        Ok(CoralDevice { 
            is_valid: true,
            name: Some(device_name.to_string()),
            vendor_id: CORAL_USB_VENDOR_ID,
            product_id: CORAL_USB_PRODUCT_ID,
        })
    }
    
    /// Create an EdgeTPU delegate for this device
    ///
    /// This function creates an EdgeTPU delegate that can be used with
    /// TensorFlow Lite to accelerate inference on this device.
    pub fn create_delegate(&self) -> Result<EdgeTPUDelegate, CoralError> {
        if !self.is_valid {
            return Err(CoralError::DeviceCreationFailed);
        }
        
        EdgeTPUDelegate::new()
    }
    
    /// Create an EdgeTPU delegate with custom options for this device
    ///
    /// This function creates an EdgeTPU delegate with custom options that
    /// can be used with TensorFlow Lite to accelerate inference on this device.
    pub fn create_delegate_with_options(&self, options: &str) -> Result<EdgeTPUDelegate, CoralError> {
        if !self.is_valid {
            return Err(CoralError::DeviceCreationFailed);
        }
        
        EdgeTPUDelegate::with_options(options)
    }
    
    /// Check if the device is valid
    pub fn is_valid(&self) -> bool {
        self.is_valid
    }
    
    /// Get the device name if available
    pub fn name(&self) -> Option<&str> {
        self.name.as_deref()
    }
    
    /// Get the vendor ID of the device
    pub fn vendor_id(&self) -> u16 {
        self.vendor_id
    }
    
    /// Get the product ID of the device
    pub fn product_id(&self) -> u16 {
        self.product_id
    }
}

impl Drop for CoralDevice {
    fn drop(&mut self) {
        // In a real implementation, this would free the device resources
        self.is_valid = false;
    }
}

/// Check if a Coral USB Accelerator is connected to the system
pub fn is_device_connected() -> bool {
    match find_coral_devices() {
        Ok(devices) => !devices.is_empty(),
        Err(_) => false,
    }
}

/// Find all Coral USB devices connected to the system
fn find_coral_devices() -> Result<Vec<CoralDevice>, CoralError> {
    let context = match Context::new() {
        Ok(ctx) => ctx,
        Err(_) => return Err(CoralError::DeviceNotFound),
    };
    
    let devices = match context.devices() {
        Ok(devs) => devs,
        Err(_) => return Err(CoralError::DeviceNotFound),
    };
    
    let mut coral_devices = Vec::new();
    
    for device in devices.iter() {
        let desc = match device.device_descriptor() {
            Ok(d) => d,
            Err(_) => continue,
        };
        
        // Check for both initial and initialized device IDs
        if (desc.vendor_id() == CORAL_USB_VENDOR_ID && desc.product_id() == CORAL_USB_PRODUCT_ID) ||
           (desc.vendor_id() == CORAL_USB_VENDOR_ID_INITIALIZED && desc.product_id() == CORAL_USB_PRODUCT_ID_INITIALIZED) {
            // Found a Coral USB Accelerator
            let name = get_device_name(&device, &desc);
            coral_devices.push(CoralDevice {
                is_valid: true,
                name,
                vendor_id: desc.vendor_id(),
                product_id: desc.product_id(),
            });
        }
    }
    
    if coral_devices.is_empty() {
        Err(CoralError::DeviceNotFound)
    } else {
        Ok(coral_devices)
    }
}

/// Get the device name from the device descriptor
fn get_device_name(device: &Device<Context>, desc: &DeviceDescriptor) -> Option<String> {
    let timeout = Duration::from_secs(1); // 1 second timeout for USB operations
    
    // Try to get manufacturer string
    if let Ok(handle) = device.open() {
        if let Ok(languages) = handle.read_languages(timeout) {
            if !languages.is_empty() {
                if let Ok(manufacturer) = handle.read_manufacturer_string(languages[0], desc, timeout) {
                    return Some(manufacturer);
                }
            }
        }
    }
    
    // If manufacturer string is not available, return None
    None
}

/// List all available Coral USB devices
pub fn list_devices() -> Result<Vec<String>, CoralError> {
    let devices = find_coral_devices()?;
    
    if devices.is_empty() {
        return Ok(Vec::new());
    }
    
    let mut result = Vec::new();
    
    for device in devices {
        let mut device_info = String::new();
        device_info.push_str(&format!("Vendor ID: 0x{:04x}", device.vendor_id()));
        device_info.push_str(&format!(", Product ID: 0x{:04x}", device.product_id()));
        
        if let Some(name) = &device.name {
            device_info.push_str(&format!(", Name: {}", name));
        }
        
        // Add information about device state (initial or initialized)
        if device.vendor_id == CORAL_USB_VENDOR_ID && device.product_id == CORAL_USB_PRODUCT_ID {
            device_info.push_str(" (Initial state)");
        } else if device.vendor_id == CORAL_USB_VENDOR_ID_INITIALIZED && device.product_id == CORAL_USB_PRODUCT_ID_INITIALIZED {
            device_info.push_str(" (Initialized state)");
        }
        
        result.push(device_info);
    }
    
    Ok(result)
}

/// Get information about the Coral USB Accelerator
pub fn get_device_info() -> Result<Vec<String>, CoralError> {
    let devices = find_coral_devices()?;
    let mut info = Vec::new();
    
    for device in devices {
        let mut device_info = String::new();
        device_info.push_str(&format!("Vendor ID: 0x{:04x}", device.vendor_id()));
        device_info.push_str(&format!(", Product ID: 0x{:04x}", device.product_id()));
        
        if let Some(name) = &device.name {
            device_info.push_str(&format!(", Name: {}", name));
        }
        
        // Add information about device state (initial or initialized)
        if device.vendor_id == CORAL_USB_VENDOR_ID && device.product_id == CORAL_USB_PRODUCT_ID {
            device_info.push_str(" (Initial state)");
        } else if device.vendor_id == CORAL_USB_VENDOR_ID_INITIALIZED && device.product_id == CORAL_USB_PRODUCT_ID_INITIALIZED {
            device_info.push_str(" (Initialized state)");
        }
        
        info.push(device_info);
    }
    
    Ok(info)
}

/// Get the EdgeTPU library version
pub fn version() -> String {
    unsafe {
        match EdgeTPULibrary::new() {
            Ok(library) => {
                match library.get_version() {
                    Ok(version) => version,
                    Err(_) => "Unknown".to_string(),
                }
            },
            Err(_) => "Unknown".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_device_creation() {
        // Test successful device creation
        let device = CoralDevice::new();
        assert!(device.is_ok());
        let device = device.unwrap();
        assert!(device.is_valid());
        assert_eq!(device.vendor_id(), CORAL_USB_VENDOR_ID);
        assert_eq!(device.product_id(), CORAL_USB_PRODUCT_ID);
        assert!(device.name().is_none());
        
        // Test device creation failure
        let device = CoralDevice::with_device_name("");
        assert!(device.is_err());
        match device {
            Err(CoralError::InvalidDeviceName) => (),
            _ => panic!("Expected InvalidDeviceName error"),
        }
    }

    #[test]
    fn test_device_with_name() {
        // Test successful device creation with name
        let device = CoralDevice::with_device_name("test_device");
        assert!(device.is_ok());
        let device = device.unwrap();
        assert!(device.is_valid());
        assert_eq!(device.vendor_id(), CORAL_USB_VENDOR_ID);
        assert_eq!(device.product_id(), CORAL_USB_PRODUCT_ID);
        assert_eq!(device.name(), Some("test_device"));
    }

    #[test]
    fn test_device_connected() {
        assert!(is_device_connected());
    }

    #[test]
    fn test_list_devices() {
        // Test successful device listing
        let devices = list_devices();
        assert!(devices.is_ok());
        let devices = devices.unwrap();
        assert_eq!(devices.len(), 1);
        assert!(devices[0].contains(&format!("VID: {:04x}", CORAL_USB_VENDOR_ID)));
        assert!(devices[0].contains(&format!("PID: {:04x}", CORAL_USB_PRODUCT_ID)));
    }

    #[test]
    fn test_version() {
        let version = version();
        assert!(!version.is_empty());
    }
    
    #[test]
    fn test_delegate_creation() {
        // Test delegate creation through device
        let device = CoralDevice::new().unwrap();
        let delegate = device.create_delegate();
        assert!(delegate.is_ok());
        let delegate = delegate.unwrap();
        assert!(delegate.is_valid());
        
        // Test delegate creation with options
        let delegate = device.create_delegate_with_options("{}");
        assert!(delegate.is_ok());
        let delegate = delegate.unwrap();
        assert!(delegate.is_valid());
    }
}